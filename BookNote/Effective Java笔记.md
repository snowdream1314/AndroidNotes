#### 1.用静态工厂方法替代构造器
- 取合适的方法名称
- getInstance获取实例和newInstance每次生成新的实例
- 便于返回原返回类型的其他子类和更改实现

```
public static <K, V> HashMap<K, V> newInstance() {
        return new HashMap<K, V>();
    }

private Map<String, String> map = HashMapUtil.newInstance();
//这样就不用重复指明参数
private Map<String, String> map = new HashMap<String, String>();
```
---
#### 2.用构建器替换多参数的构造器
- JavaBeans模式，无法用在并发环境
- builder模式，需要注意在setter方法中检查约束条件，不满足抛出IllegalArgumentException
---
#### 3.用私有构造器强化和枚举强化单例模式
---
#### 4.通过私有构造器强化不可实例化的能力
---
#### 5.避免创建不必要的对象，特别是在循环中或是频繁调用的方法里面

```
String s = new String("ssss");
//应该是这样
String s = "ssss";
```
- 可以考虑用静态代码块来重用已知不会被修改的对象
- 需要注意自动装箱基本类型

```
Long sum = 0L;
for (int i=0; i<Integer.MAX_VALUE; i++) {
    sum += i;
}
//这里的Long相对于long就是装箱基本类型，每次累加都会生成新的实例，需要留意
```
---
#### 6.消除过期引用

```
public Object pop() {
    if(size == 0) {
        throw new EmptyStackException();
    }
    Object result = elements[--size];
    elements[size] = null;
    return result;
}
```
---
#### 7. 避免使用终结方法
---
#### 8.覆盖equals方法
###### 需要满足约定：自反性、对称性、传递性、一致性、x.equals(null)为false
    
- 自反性：
> x.equals(x) 必须返回true，其中x非null

- 对称性
> 对任何非null的引用值x,y
x.equals(y)为true，则y.equals(x)也必须返回true

- 传递性
> 对任何非null的引用值x,y,z
x.equals(y)为true，y.equals(z)为true，则x.equals(z)必须为true

- 一致性
>对任何非null的引用值x,y，只要equals比较操作用到的对象中的信息没有改变，多次调用x.equals(y)返回的结果也不改变

###### 注意点
- 覆盖equals方法时总要覆盖hashcode方法
- 不要让equals方法过于智能，即不要让equals方法的等价范围过大
- 不要将equals方法中的Object对象替换为其他类型，一定要加@Override注解来避免错误

```
//这样写就是错误的
public boolean equals(MyClass o) {
    
}
```
###### 高效地实现equals方法步骤
- 使用==操作符检查“参数是否为这个对象的引用
- 使用instanceof操作符检查“参数是否为正确的类型”
- 把参数转换成正确的类型
- 对于该类中的每个关键域，检查参数中的域是否和该对象中的域相匹配
---
#### 9.覆盖equals方法时总要覆盖hashcode方法
---
#### 10.始终要覆盖toString方法
> toString方法会在打印对象或是调试或是assert或是字符串串联操作符（+）时自动调用
---
#### 11.谨慎覆盖clone方法
- 一般不覆盖clone方法
- 用拷贝构造器或是拷贝工厂方法替换
---
#### 12.考虑实现Comparable接口
- 遵循自反性、传递性和对称性，同时建议等同性和equals方法返回同样的结果
- 利用现成的Comparator；
- 整数型基本类型可以用>和<关系操作符；
- 浮点域用Double.compare或者Float.compare；
- 数组域则应用到每个元素上
- 有多个关键域，则从最关键的域开始
---
#### 13.使类和成员的可访问性最小化
- 实例域不能是公有的
- 类中的常量用公有的静态final域来暴露，并且名称大写，单词间用下划线隔开
- 公有的静态final域所引用的对象都是不可变对象
- 实现的接口中的方法都是公有的
- 子类中的访问级别不允许低于超类中的访问级别
- 长度非零的数组总是可变的，类具有公有的静态final数组域或者返回这种域的访问方法，都是错误的，可以修改如下

```
private static final Thing[] PRIVATE_VALUES = {...}
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```
或者用返回数组的备份的方法

```
private static final Thing[] PRIVATE_VALUES = {...}
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}
```
- 总结起来就是：除了公有静态final域的特殊情形外，公有类都不应该包含公有域
---
#### 14.在公有类中使用访问方法而不是公有域
- 也就是使用setter和getter方法
--- 
#### 15.使可变性最小化
##### 五条规则
- 不要提供任何会修改对象状态（属性）的方法（不要提供setter方法）
- 保证类不会被扩展（一般做法是使这个类成为final的）
- 使所有的域都是final的
- 使所有的域都成为私有的
- 确保对于任何可变组件的互斥访问
##### 函数式模式保持不变性

```
//复数
public final Complex {
    private final double re;
    private final double im;
    
    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }
    //通过函数式的方法，将对域的计算结果通过生成新的Complex实例返回
    public Complex add(Complex c) {
        return new Complex(re+c.re, im+c.im);
    }
}
```
##### 不可变对象本质上是线程安全的，它们不要求同步
##### 对于频繁用到的值，不可变类可以为客户端提供公有的静态final常量
比如对于上面复数的例子，我们就可以提供一些常量

```
public static final Complex ZERO = new Complex(0,0);
public static final Complex ONE = new Complex(1,0);
```
##### 不可变对象不需要进行保护性拷贝
##### 不可变类的缺点是：对于每个不同的值都需要一个单独的对象
##### 可以通过将所有的构造器都变成私有的或是包级私有的，并添加公有的静态工厂来代替公有的构造器，从而让不可变类变成final的
##### 不可变类可以允许有一个或多个非final域，并且可以通过“延迟初始化”的方法来提高不可变类的性能
```
//比如对于不可变类的hashCode
private volatile int hashCode;
@Override
public int hashCode() {
    int result = hashCode;
    if(result == 0) {
        result = 17;
        ...
        hashCode = result;
    }
    return result;
}
```
##### 如果不可变类实现Serializable接口，并且它包含一个或多个指向可变对象的域，就必须提供一个显示的readObject或者readResolve方法，或者使用ObjectOutputStream.writeUnshared和ObjectInputStreeam.readUnshared方法
##### 限制类的可变性，尽可能得保证域是final的
##### 不要在构造器或者静态工厂之外提供公有的初始化方法，页不要提供重新初始化方法
---
#### 16.复合优先于继承
- 只有当两个类之间确实存在“is-a”的关系时才能使用继承
- 利用复合和转发实现包装类来代替继承
- 包装类不适合用于回调当中
---
#### 17.要么为继承而设计，并提供文档说明，要么就禁止继承
- 需要说明可覆盖方法的自用性，也就是与哪些其他方法有关联影响
- 构造器绝不能调用可被覆盖的方法
- clone和readObject方法都不可以调用可覆盖的方法
- 通过声明类为final或是将构造器私有化并添加静态工厂的方式来禁止子类化
- 为了能够安全地进行子类化，可以将可覆盖的方法代码体移到私有的辅助方法中，并且让每个可覆盖的方法调用它的私有辅助方法，以移除可覆盖方法的自用性
---
#### 18.接口优于抽象类
- 当比灵活性和功能比演变的容易性更重要时，接口通常是定义允许多个实现的类型的最佳途径，否则应该用抽象类来定义类型
- 应该同时提供接口的骨架实现类，命名为AbstractInterface，这里的Interface为所实现的接口名字
- 尽可能谨慎地设计所有的公有接口，并通过编写多个实现类来进行测试
--- 
#### 19.接口只用于定义类型，不应该用于导出常量
---
#### 20.类层次优于标签类
- 利用抽象和继承的类层次关系替换在一个类中根据标签实现不同的功能
---
#### 21.用函数对象表示策略
- 声明一个接口表示该策略
- 为每个具体的策略声明一个实现该接口的类
- 如果一个策略只被使用一次，通常使用匿名类
- 如果一个策略被设计用来重复使用，通常要被实现为私有的静态成员类，并通过公有的静态final域被导出，其类型为该策略接口
---
#### 22.优先考虑静态成员类
- 非静态成员类的每个实例都隐含外部类的引用，容易导致内存泄漏
---
#### 23.不要使用原生态类型
- 原生态类型是和泛型相对应
- Set<Object>是个参数化类型，Set<?>是个通配符类型，Set则是个原生态类型；前2者是安全的，最后一种不安全
---
#### 24.消除非受检警告
- 只有在可以证明引起警告的代码是类型安全的情况下，才可以用@SuppressWarnings("unchecked")注解来禁止这条警告
- @SuppressWarnings("unchecked")注解要用在尽可能小的范围中，并记录下原因
---
#### 25.列表优先于数组
- 数组是是协变且可具体化的，泛型是不可变的且可以被擦除的
- 数组提供了运行时的类型安全，但没有编译时安全；泛型则相反
---
#### 26.优先考虑泛型
- 给需要泛型化的类添加一个或多个类型参数，参数名称通常是E
- 用相应的类型参数替换所有的Object类型
- 编译，并消除所有的错误和警告
- 在处理创建泛型数组的警告时，有2种方法：创建一个Object数组，并将它转换成泛型数组类型；或者将数组域的类型E[]改为Object[]，然后再将获取到的元素转换为E；最后消除非受检警告
----
#### 27.优先考虑泛型方法
泛型方法举例,E为类型参数
```
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
    Set<E> result = new HashSet<E>(s1);
    result.addAll(s2);
    return result;
}
```
---
#### 28.利用有限制通配符来提升API的灵活性
- 参数类型是被用于消费的，即生产者，则用<? extends T>
- 参数类型是被用于生产的，即消费者，则用<? super T>
- 不要用通配符类型作为返回类型
- 对于27中的方法，我们可以改为

```
public static <E> Set<E> union(Set<? extends E> s1, Set<? extends E> s2) {
    Set<E> result = new HashSet<E>(s1);
    result.addAll(s2);
    return result;
}
```
##### 一般来说，如果类型参数只在方法声明中出现一次，就可以用通配符取代它
##### 所有的comparable和comparator都是消费者
---
#### 29.优先考虑类型安全的异构容器
- 将类型参数放在键上，从而避开每个容器只能有固定数目的类型参数的限制，并且确保类型安全，就是类型安全的异构容器
---
#### 30.用enum代替int常量
- 枚举提供编译时安全
- 每个枚举常量后面括号中的数值就是传递给构造器的参数
- 为了将数据和枚举常量关联起来，得声明实例域，并编写一个带有数据并将数据保存在域中的构造器
- 枚举天生就是不可变的，因此所有的域都应该为final
- 枚举的toString方法默认返回每个枚举值的声明名称，可以通过覆盖toStirng方法进行修改
- 如果一个枚举类具有普遍适用性，它就应该成为一个顶层类；如果只用在一个特定顶层类中，就应该成为该顶层类的一个成员类
- 可以为每个枚举常量添加枚举类型中的抽象方法的实现

```
public enum Operation {
    PLUS {
        double apply(double x, double y) {
            return x + y;
        }
    }
    
    abstract double apply(double x, double y);
}
```
- 摇增加特定于常量的方法，可以考虑用策略枚举，也就是在枚举中再增加一个私有的嵌套枚举
- 每当需要一组固定常量的时候应该使用枚举
---
#### 31.用实例域代替序数
- 所有的枚举都有一个ordinal方法，它返回每个枚举常量在类型中的数字位置
- 永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中
- 不要使用ordinal方法
---
#### 32.用EnumSet代替位域
---
#### 33.用EnumMap代替序数索引
---
#### 34.用接口模拟可伸缩的枚举
---
#### 35.注解优先于命名模式
---
#### 36.坚持使用Override注解
---
#### 37.用标记接口定义类型
---
#### 38.检查参数的有效性
- 非公有的方法通常应该使用断言（assert语句）来检查参数
- 对于有些参数，方法本身没有用到，却被保存起来供以后使用，这类参数必须要检验有效性
- 编写方法和构造器的应该考虑参数有哪些限制，把这些限制写到文档中，并且在方法体的开头处通过显示得检查来实施这些限制
---
#### 39.必要时进行保护性拷贝
- 对于构造器得每个可变参数进行保护性拷贝是必要的
```
//使用备份对象作为Period的组件，避免可变参数的影响
public Period(Date start, Date end) {
    this.start = new Date(start.getTime);
    this.end = new Date(end.getTime);
    if (this.start.compareTo(this.end) > 0) {
        throw new IllegalArgumentException(start + " after " + end);
    }
}
```
- 保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是原始的对象；这样可以避免在检查完有效性到保护性拷贝结束前之间的时间段内参数被改变
- 对于参数类型可以被不可信任方子类化的参数，不要使用clone方法进行保护性拷贝
- 为了防止类提供的访问方法对其内部可变成员的改变，还需要使访问方法返回可变内部域的保护性拷贝

```
public Date start() {
    return new Date(start.getTime());
}
```
##### 每当编写方法或是构造器时，都要考虑传入的对象是否是可变的，如果不能容忍对象进入数据结构中以后还能发生变化，就必须进行保护性拷贝，并且让拷贝后的对象而不是原始对象进入到数据结构中
##### 把一个指向内部组件的引用返回给客户端之前，也需要进行保护性拷贝。
##### 长度非零的数组总是可变的，因此在把内部数组返回给客户端之前，应该总要进行保护性拷贝，方法有2种，见第13条
---
#### 40.谨慎设计方法签名
- 谨慎地选择方法的名称：易于理解、风格一致、大众认可
- 不要过于追求提供便利的方法
- 避免过长的参数列表：分解成多个方法、创建辅助类、从对象构建到方法调用都用Builder模式
- 对于参数类型，优先使用接口而不是类，比如传Map接口为参数，而不是HashMap
- 对于boolean参数，优先使用2个元素的枚举类型
---
#### 41.慎用重载
- 调用覆盖方法是根据被调用对象的运行时类型，而调用重载的哪个方法是根据参数的编译时类型
- 不要导出两个具有相同参数数目的重载方法
---
#### 42.慎用可变参数
---
#### 43.返回零长度的数组或者集合，而不是null
---
#### 44.为所有导出的API元素编写文档注释
---
#### 45.将局部变量的作用域最小化
- 最有力的方法是再第一次使用局部变量的地方声明
- 几乎每个局部变量的声明都应该包含一个初始化表达式
- 优先使用for循环
- 使方法小而集中，不要把不同的操作合并到一个方法中
---
#### 46.for-each循环优先于传统的for循环
只有三种情况下无法使用for-each循环:
- 过滤：需要遍历并删除指定的元素时
- 转换：需要遍历并转换部分元素时
- 平行迭代：需要并行遍历多个集合时
---
#### 47.了解和使用类库
---
#### 48.如果需要精确的答案，请避免使用float和double
- float和double类型尤其不适合用于货币计算
-  如果数值范围没有超过9位十进制数字，就可以使用int；如果不超过18位数字，就可以使用long，如果数值可能超过18位数字，就必须使用BigDecimal
---
#### 49.基本类型优先于装箱基本类型
- Java类型系统由基本类型，如int、double、boolean，和引用类型组成
- 每个基本类型都有一个对应的引用类型，也就是装箱基本类型，如Integer、Double、Boolean
##### 基本类型和装箱类型有三个主要区别
- 基本类型只有值，而装箱基本类型则具有与它们值不同的同一性（也就是说可以值相同但引用不同）
- 基本类型只有功能完备的值，而装箱基本类型除了功能值还有一个非功能值：null
- 基本类型通常比装箱基本类型更节省时间和空间
##### 装箱基本类型比较数值大小需要先进行拆箱，也就是转化为基本类型
##### 当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱，而如果null对象引用被自动拆箱就会报NullPointerException异常
##### 装箱基本类型的用处
- 作为集合中的元素、键和值
- 在参数化类型中，必须使用装箱基本类型，比如ThreadLocal<Integer>,而不能是ThreadLocal<int>
- 在进行反射的方法调用时，必须使用装箱基本类型
##### 综上总结如下：
- 当可以选择时，基本类型要优先
- 当程序用==操作符比较2个装箱基本类型时，实际上是做了一个同一性比较，结果肯定不是希望的
- 当程序涉及装箱和拆箱基本类型的混合类型计算时，会进行拆箱，会抛出NullPointerException异常
- 当程序装箱了基本类型值时，会导致高开销和不必要的对象创建
---
#### 50.如果其他类型更适合，则尽量避免使用字符串
- 字符串不适合代替其他的值类型
- 字符串不适合代替枚举类型
- 字符串不适合代替聚集类型
- 字符串不适合代替能力表
--- 
#### 51.当心字符串连接的性能
- 不要使用字符串连接操作符来合并多个字符串，用StringBuilder的append方法
---
#### 52.通过接口引用对象
- 应该优先使用接口而不是类来引用对象
- 如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明
- 如果没有适当的接口类型，可以用类来引用对象，优先用相关类的基类（往往是抽象类）来引用
---
#### 53.接口优先于反射机制
---
#### 54.谨慎地使用本地方法
---
#### 55.谨慎地进行优化
- 努力编写好的程序而不是快的程序
- 不要因为性能而牺牲合理的结构
---
#### 56.遵守普遍接受的命名惯例
---
#### 57.只针对异常的情况才使用异常
- 设计良好的API不应该强迫它的客户端为了正常的控制流而使用异常。如果类具有状态相关的方法，则也应该有单独的状态测试方法。比如Iterator接口有一个状态相关的next方法，和相对应的状态测试方法hasNext
- 如果对象将在缺少外部同步的情况下备并发访问，或者可被外界改变状态，也可以通过返回“可识别的返回值”，如null值，来指示状态方法的状态
---
#### 58.对可恢复的情况使用受检异常，对编程错误使用运行时异常
- Java三种可抛出结构：受检的异常、运行时异常、错误
- 如果期望调用者能够适当地恢复，就应该使用受检的异常。通过抛出受检的异常，强调调用者在一个catch子句中处理该异常
- 你实现的所有未受检的抛出结构都应该是RuntimeException的子类
---
#### 59.避免不必要地使用受检的异常
---
#### 60.优先使用标准的异常
---
#### 61.抛出与抽象相对应的异常
- 更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常
- 处理来自低层异常的最好做法是在调用低层方法之前确保它们会成功执行
---
#### 62.每个方法抛出的异常都要有文档
- 始终要单独地声明受检异常，并且利用Javadoc的@throws标记，准确记录下抛出每个异常的条件
- 要为每个受检的异常提供单独的throws子句，不要为未受捡的异常提供throws子句。
- 要为编写的每个方法所能抛出的每个异常建立文档
---
#### 63.在细节消息中包含能捕获失败的信息
- 为了捕获失败，异常的细节信息应该包含所有的“对该异常有贡献”的参数和域的值
---
#### 64.努力使失败保持原子性
- 失败原子性是指失败的方法调用使对象保持在调用之前的状态
##### 保持失败原子性的方法：
- 设计不可变对象
- 对于可变对象，在操作之前检查参数的有效性
- 调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生
- 编写一段恢复代码，拦截操作过程中的失败并使对象回滚到操作开始之前的状态。主要用于永久性（基于磁盘的）数据结构
- 在对象的一份临时拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容
---
#### 65.不要忽略异常
---
#### 66.同步访问共享的可变数据
- 不要使用Thread.stop
- volatile修饰符不执行互斥访问，但可以保证任何一个线程读取该域的时候都将看到最近刚刚被写入的值
- 如果读和写操作没有都被同步，同步就不会起作用
##### 安全发布对象的引用方法：
- 保存在静态域中，作为类初始化的一部分
- 保存在volatile域、final域或者通过正常锁定访问的域中
- 保存在并发的集合中
---
#### 67.避免过渡同步
- 在一个被同步的区域内，不要调用设计成要被覆盖的方法或者是由客户端以函数对象的形式提供的方法
- 在同步区域内做尽可能少的工作
- 如果一个可变的内要并发使用，应该使这个类变成是线程安全的。通过内部同步可以获得比从外部锁定整个对象更高的并发性；否则就不要在内部同步
- 如果在内部同步了类，可以通过分拆锁、分离锁、非阻塞并发控制来实现高并发性
- 如果方法修改了静态域，那么也必须同步对这个域的访问
---
#### 68.executor和task优先于线程
---
#### 69.并发工具优先于wait和notify
- Executor Framework
- 并发集合，如ConcurrentHashMap
- 同步器，如倒计数锁存器CountDownlatch和Semaphpre
---
#### 70.线程安全性的文档化
---
#### 71.慎用延迟初始化
---
#### 72.不要依赖于线程调度器
---
#### 73.避免使用线程组
---
#### 74.谨慎地实现Serializable接口
- 实现Serializable接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性
- 实现Serializable接口的第二个代价是，它增加了出现bug和安全漏洞的可能性
- 实现Serializable接口的第三个代价是，随着类发行新的版本，相关的测试负担也增加了
- 为了继承而设计的类应该尽可能少地去实现Serializable接口，用户的接口也应该尽可能少地继承Serializable接口
- 对于为了继承而设计的不可序列化的类，应该考虑提供一个无参构造器，这样子类才能做到序列化
- 内部类不应该实现Serializable
---
#### 75.考虑使用自定义的序列化形式
- 不管选择哪种序列化的形式，都要为自己编写的每个序列化的类声明一个显示的序列版本UID
---
#### 76.保护性地编写readObject方法
- 对于每个可序列化的不可变类，如果它包含了私有的可变组件，那么在它的readObject方法中，必须要对这些组件进行保护性拷贝
- readObject方法中必须执行构造器所要求的所有有效性检查，检查失败则抛出InvalidobjectException异常，并且这些检查应该在保护性拷贝之后
- 对于非final的可序列化的类，readObject方法不可以调用可被覆盖的方法，无论是直接调用还是间接调用
- 如果整个对象图在被反序列化之后必须进行验证，就应该使用ObjectInputValidation接口
---
#### 77.对于实例控制，枚举类型优先于readResolve
- 如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域则必须声明为transient的
- 应该尽可能使用枚举类型来实施实例控制的约束条件
---
#### 78.考虑用序列化代理代替序列化实例
- 对于不能被客户端扩展的类，在编写readObject或者writeobject方法时，应该考虑使用序列化代理模式