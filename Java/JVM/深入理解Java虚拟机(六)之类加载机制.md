> 类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型
- Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，Java的动态可扩展特性就是依赖运行期动态加载和动态连接实现的
####  类加载时机
- 类从被加载到虚拟机，到卸载出内存，包括：加载、验证、准备、解析、初始化、使用和卸载这几个过程。其中，验证、准备和解析统称为连接
- 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的
##### 虚拟机规范规定有且只有5种情况必须立即对类进行初始化(而加载、验证、准备自然需要在此之前开始)
- 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：
    * 使用new关键字实例化对象的时候
    * 读取或设置一个类的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候
    * 调用一个类的静态方法的时候
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则先要触发其初始化
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
- 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类
- 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic、REF_putstatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化
- 以上5种场景的行为称为对一个类进行主动引用
##### 几个对类的被动引用(被动引用不会触发初始化)
- 对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化
```
//父类
public class SuperClass{
    static {
        System.out.println("SuperClass init!");
    }

    public static int value = 123;

}

//子类
public class SubClass extends SuperClass {
    static {
        System.out.println("SubClass init!");
    }
}

//只会输出“SuperClass init!”，而不会输出“SubClass init!”
//通过子类引用父类的静态字段，不会导致子类初始化。
public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }
}
```
- 通过数组定义来引用类，不会触发该类的初始化

```
//将上面的NotInitialization中的main方法里面稍作修改
//不会输出“SuperClass init!”，因为没有触发SuperClass的初始化
public class NotInitialization {
    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[10];
    }
}
```
- 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

```
public class ConstClass{
    static {
        System.out.println("ConstClass init!");
    }
    
    public static final String HELLOWORLD = "hello world";
}

//不会输出“ConstClass init!”
public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(ConstClass.HELLOWORLD);
    }
}
```
##### 接口的加载的特殊性
- 一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候(如引用接口定义的常量)才会初始化

---
#### 类加载的过程
##### 加载
- 加载过程，虚拟机需要完成3件事：
    * 通过一个类的全限定名来获取定义此类的二进制字节流
    * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
    * 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
- 数组类本身不通过类加载器加载，它是由Java虚拟机直接创建的，而数组类的元素类型最终是靠类加载器去创建的
- 加载阶段与连接阶段的部分内容(如一部分字节码文件格式验证动作)是交叉进行的
##### 验证
- 验证阶段大致可分为4个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证
- 文件格式验证主要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储
- 元数据验证是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求
- 字节码验证主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，这个阶段将对类的方法体进行校验分析
- 符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验，目的是确保解析动作能正常执行
##### 准备
- 准备阶段是正式为类变量(static修饰的变量)分配内存并设置初始值的阶段，这些类变量所使用的内存都将在方法区中进行分配
- 初始值通常都是数据类型的零值，比如int型就是0，boolean型就是false等。而给类变量赋值程序员设置的初始值，则要到初始化阶段
```
//在准备阶段，value会被赋值为初始值0；到了初始化阶段才会赋值为123
//因为把value赋值为123的putstatic指令是程序编译后存放于类构造器<clinit>方法中的
public static int value = 123;
```
- 如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指的值

```
//在准备阶段，value会被赋值为初始值123，因为编译时Javac会为value生成ConstantValue属性
public static final int value = 123;
```
##### 解析
- 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程
- 符号引用和直接引用
    * 符号引用：以一组符号来描述所引用的目标，可以使任何形式的字面量，只要使用时能无歧议地定位到目标即可。与虚拟机的内存布局无关，引用的目标不一定已经加载到内存中。各个虚拟机能接受的符号引用必须一致
    * 直接引用：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。和虚拟机实现的内存布局有关。如果有了直接引用，那引用的目标必定已经在内存中存在
- 虚拟机规定在执行16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析：anewarray、checkcast、getfield、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、new、putfield和putstatic
- 除了invokedynamic指令外，虚拟机实现可以通过在运行时常量池中直接记录直接引用，并把常量标示为已解析状态，来对第一次解析的结果进行缓存
- 在同一个实体中，如果一个符号引用之前被成功解析过，那后面的引用解析就应当一直成功；反之也是
- 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符
- 在字段解析中，如果有一个同名字段同时出现在现在类或接口的接口和父类中，或者同时在自己或父类的多个接口中出现，那编译器将可能拒绝编译

##### 初始化
- 初始化阶段真正开始执行类中定义的Java程序代码。初始化阶段是执行类构造器<clinit>()方法的过程
- <clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，收集的顺序由语句在源文件中出现的顺序决定。静态语句块中只能访问到定义在静态语句块之前的变量，可以赋值但不能访问后面定义的变量。

```
public class Test {
    static {
        i = 0;  //给变量赋值可以正常编译通过
        System.out.print(i);    //这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```
- <clinit>()方法不需要显示地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此，虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object
- 父类中定义的静态语句块要优先于子类的变量赋值操作
- <clinit>()方法对于类或者接口来说并不是必需的
- 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此也会生成<clinit>()方法。执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
- 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，同一时间只会有一个线程去执行类的<clinit>()方法。同一个类加载器下，一个类型只会初始化一次，即<clinit>()方法只会执行一次。

---
#### 类加载器
- 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性。比较2个类是否“相等”只有在这2个类是在同一个类加载器加载的前提下才有意义。这里所指的“相等”包括：equals()方法、isAssignableFrom()方法、isInstance()方法、instanceof等判定情况
- 系统提供的类加载器包括以下3种：启动类加载器<--扩展类加载器<--应用程序类加载器<--自定义的类加载器
- 类加载器之间遵循双亲委派模型的层次关系，除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。其中的父子关系都是使用组合关系来实现，通过组合关系复用父加载器的代码
- 双亲委派模型的好处是Java类型随着它的类加载器一起具备了一种带优先级的层次关系。比如无论哪个类加载器加载java.lang.Object类，最终都是委派给模型顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。