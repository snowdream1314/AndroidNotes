#### 判断对象是否已死
- 2种算法：引用计数算法和可达性算法
> 引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的
- 特点是实现简单，判定效率高；缺点是很难解决对象间相互循环引用的问题
- 主流的Java虚拟机里面没有选用引用计数算法来管理内存
> 可达性分析算法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路称为引用链，当一个对象到GC Roots没有任何引用链，即从GC Roots到这个对象不可达时，证明这个对象是不可用的
- 能作为GC Roots的对象包括：
    * 虚拟机栈（栈帧中的本地变量表）中引用的对象
    * 方法区中类静态属性引用的对象
    * 方法区中常量引用的对象
    * 本地方法栈中JNI（即一般说的Native方法）引用的对象
##### 四种引用
> 强引用: 如Object obj = new Object()这类，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象

> 软引用：描述一些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存才会抛出内存溢出异常

> 弱引用：用来描述非必需的对象，强度比软引用还要弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象

> 虚引用：也称为幽灵引用或者幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会影响其生存时间，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知

##### 2次标记
- 不可达的对象并非“非死不可”，要宣告一个对象死亡需要经历2次标记过程
- 如果对象在进行可达性分析后发现不可达，就会被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法 。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这2种情况都视为“没有必要执行”
- 如果对象被判定为有必要执行finalize()方法，这个对象会被放置在一个F-Queue的队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程去执行。但虚拟机并不承诺会等待fianlize()方法执行完
- fianlize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue队列中的对象进行第二次小规模的标记，对象只要在fianlize()方法中重新与GC Roots节点上的任意一个对象关联就可以在第二次标记时被移出“即将回收”的集合
- 需要注意的是，任何一个对象的fianlize()方法都只会被系统自动调用一次
- 最重要的是，不要使用fianlize()方法
##### 回收方法区（或是HotSpot虚拟机中的永久代）
- Java虚拟机规范不要求虚拟机在方法区实现垃圾收集
- 永久代的垃圾收集主要回收2部分内容：废弃常量和无用的类
- 废弃常量的回收：没有任何对象引用常量池中的常量，也没有其他地方引用这个字面量，如有必要，就会被清理出常量池
- 无用的类的回收条件：
    * 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
    * 加载该类的ClassLoader已经被回收
    * 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
- 是否进行类回收还跟虚拟机的参数设置有关
